Monday,  9 June 2025, 19:33

The goal here is to delegate access control DECISIONS from Apigee to a Cloud Run service.
And allow Apigee to ENFORCE the access control decision.
For MCP servers.

How will this work?  In short we want our Apigee proxy to call out to something external,
to ask for an access control decision. That is easy enough, but the trick is, this will be happening _very often_ so it needs to be 

With Apigee X we can use an ExternalCallout policy to call to a GRPC service, for high efficiency.

We can implement the service in any language that supports GRPC; in this case I chose .NET and C#.  

Another design choice is how to store the access rules; I chose to use a GSheet to store  the access rules and role mappings.

So:
 1. MCP client calls aPI proxy with Access Token
 2. Apigee verifies Access token
 3. Apigee API proxy calls to GRPC Service implemented in  C#, passing it access control info (tool name, subject, etc)
 4. C# service calls to Google Sheets to retrieve rules
 5. C# service applies rules and returns a "ALLOW" or "DENY" to the proxy
 6. proxy enforces that decision. 
 7. proxy proxies to target



# =======================================================================================
## Testing and running the MCP service locally

./91-build-image-for-local-execution.sh
./92-run-image-locally.sh

# to test, use MCP inspector from a terminal on cloudtop 
  npx @modelcontextprotocol/inspector


# CLEAN UP images AFTERWARDS
# list containers
podman ps -a

# remove unused container
podman rm <container_id>

# list images
podman images

# remove unused image
podman rmi <image_id>

# =======================================================================================

Next:
 step 4 - create sheet 

 I need to use admin@altostrat ID. 
 gcca default

Not sure how to test the access control service.
That seems a little unwieldy. I don't remember how I tested it in
the prior go-round.  Trial and error?


# =======================================================================================


The .NET service uses this service account:
  dotnet-excallout@dchiesa-argolis-2.iam.gserviceaccount.com



# Create a target server

curl -i -H "Authorization: $TOKEN" -X POST \
 'https://apigee.googleapis.com/v1/organizations/infinite-epoch-2900/environments/eval/targetservers'\
 -d '{
  "name": "dotnet-access-control-server",
  "description": ".NET GRPC External Callout",
  "host": "dotnet-excallout-server-511582533367.us-west1.run.app",
  "port": 443,
  "isEnabled": true,
  "sSLInfo": {
    "enabled": true
  },
  "protocol": "GRPC"
}'



SA_EMAIL="${SERVICE_ROOT}@${PROJECT}.iam.gserviceaccount.com"
MY_EMAIL=$(gcloud config get-value core/account)

gcloud iam service-accounts add-iam-policy-binding ${SA_EMAIL} \
  --member user:${MY_EMAIL} --role roles/iam.serviceAccountTokenCreator \
  --project $PROJECT



SCOPES_REQUIRED="https://www.googleapis.com/auth/spreadsheets,https://www.googleapis.com/auth/cloud-platform,https://www.googleapis.com/auth/drive,https://www.googleapis.com/auth/drive.file"


gcloud auth print-access-token --impersonate-service-account ${SA_EMAIL} --scopes=${SCOPES_REQUIRED}




test run from command line:
 SA_EMAIL=$SA_EMAIL PROJECT_ID=dchiesa-argolis-2 SHEET_ID=1-s1H2vEB9aefDPbdPSRvo4nFnIdNxwxQORbHy8_0Ib8 dotnet run --project server 



(I have no client app, so cannot test it directly)


todo:

- Build a client app in .NET, to be able to test the server locally. 

- Writeup a proper README

- Push to Github

- Record a screencast walkthrough of this 



